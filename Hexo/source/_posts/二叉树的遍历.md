---
title: 二叉树的遍历
date: 2021-03-06 14:39:12
categories: 算法
tags: [算法, 数据结构, 二叉树]
---

<!--more-->

## 先序遍历

### 递归

先遍历根节点，然后是左子树，接着遍历右子树

```C++
/*
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};
*/
void PreOrder(TreeNode* root){
    if(root == NULL){
        return;
    }
    std::cout << root->val << std::endl;
    PreOrder(root->left);
    PreOrder(root->right);
}
```

### 非递归

构建一个栈，先将根节点压入栈中，每次先弹出栈顶的结点，再依次将右子树和左子树压入，直到栈空

```C++
/*
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};
*/
void PreOrder(TreeNode* root){
    if(root == NULL){
        return;
    }
    stack<TreeNode*> s;
    s.push(root);
    while(!s.empty()){
        TreeNode* pNode = s.top();
        s.pop();
        std::cout << pNode->val << std::endl;
        if(pNode->right){
            s.push(pNode->right);
        }
        if(pNode->left){
            s.push(pNode->left);
        }
    }
}
```

## 中序遍历

### 递归

先遍历左子树，再到根节点，然后是右子树

```C++
/*
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};
*/
void InOrder(TreeNode* root){
    if(root == NULL){
        return;
    }
    InOrder(root->left);
    std::cout << root->val << std::endl;
    InOrder(root->right);
}
```

### 非递归

新建一个栈，将根节点先压入栈中，先把整个左子树依次压入栈中，然后对于叶节点进行回退，弹出叶节点的父节点，接着对父节点的右子树进行判断，直到栈空并且当前结点为空

```C++
/*
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};
*/
void InOrder(TreeNode* root){
    stack<TreeNode*> s;
    TreeNode* pNode = root;
    while(pNode||!s.empty()){
        while(pNode){
            s.push(pNode);
            pNode = pNode->left;
        }
        TreeNode* newNode = s.top();
        s.pop();
        std::cout << newNode->val << std::endl;
        pNode = newNode->right;
    }
}
```

## 后序遍历

### 递归

先遍历左右子树，最后到根节点

```C++
/*
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};
*/
void PosOrder(TreeNode* root){
    if(root == NULL){
        return;
    }
    PosOrder(root->left);
    PosOrder(root->right);
    std::cout << root->val << std::endl;
}
```

### 非递归

#### 方法一

新建两个栈。第一步类似于先序遍历的方法，先将根节点压入栈 1 中，弹出栈顶元素，将左子树和右子树依次压入，弹出的元素同时放入栈 2 中，直至栈 1 为空。再将栈 2 中的元素依次弹出则为后序遍历

```C++
/*
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};
*/
void PosOrder(TreeNode* root){
    if(!root){
        return;
    }
    stack<TreeNode*> s1;
    stack<TreeNode*> s2;
    s1.push(root);

    while(!s1.empty()){
        TreeNode* pNode = s1.top();
        s2.push(pNode);
        s1.pop();
        if(pNode->left){
            s1.push(pNode->left);
        }
        if(pNode->right){
            s1.push(pNode->right);
        }
    }
    while(!s2.empty()){
        std::cout << s2.top()->val << std::endl;
        s2.pop();
    }
}
```

#### 方法二

新建一个栈。先将根节点压入栈中，记录上一次弹出栈的结点和当前的栈顶结点。假设当前结点有左子树且左右子树都没有被遍历过，就将左子树压入栈中，否则假设当前结点有右子树且右子树没有被遍历过，就将右子树压入栈中，否则，即左右子树都遍历过或为叶节点就弹出栈顶元素，重复直至栈空

```C++
/*
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};
*/
void PosOrder(TreeNode* root){
    if(!root){
        return;
    }
    stack<TreeNode*> s;
    s.push(root);
    TreeNode* pNode = root;
    TreeNode* cur = NULL;

    while(!s.empty()){
        cur = s.top();
        if(cur->left && pNode!=cur->left && pNode!=cur->right){
            s.push(cur->left);
        }
        else if(cur->right && pNode!=cur->right){
            s.push(cur->right);
        }
        else{
            std::cout << s.top()->val << std::endl;
            s.pop();
            pNode = cur;
        }
    }
}
```

## 层序遍历

建立一个队列，先将根节点放入队列中。弹出队首结点，弹出的结点有右子树则将右子树放进来，有左子树则将左子树放进来，直至队列为空

```C++
/*
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL){}
};
*/
void LevelOrder(TreeNode* root){
    if(!root){
        return;
    }
    queue<TreeNode*> q;
    q.emplace_back(root);
    TreeNode* pNode;
    while(!q.empty()){
        pNode = q.front();
        std::cout << pNode->val << std::endl;
        q.pop();
        if(pNode->left){
            q.push(pNode->left);
        }
        if(pNode->right){
            q.push(pNode->right);
        }
    }
}
```
